# -*- coding: utf-8 -*-
"""制作神经网络.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qHM__B8sTzqtkQ4xmXSXfCwYREH3D053
"""

#框架代码 
class neuralNetwork:
  #输入初始化函数
  def __init__():
    pass
  #训练  优化权重
  def train()：
    pass
  #查询 输出
  def query():
    pass

import numpy
# SciPy Python库中函数中，S函数称为expit（）。scipy.special for the sigmoid function expit()
import scipy.special
# 神经网络类定义
class neuralNetwork:
    
    
    # 初始化神经网络
    def __init__(self, inputnodes, hiddennodes, outputnodes, learningrate):
        # 设置每个输入、隐藏、输出层中的节点数
        self.inodes = inputnodes
        self.hnodes = hiddennodes
        self.onodes = outputnodes
        
        # 链接权重矩阵, wih and who
        # 数组中的权重是w_ij，其中链接是从节点i到下一层中的节点j。w11 w21 w12 w22 etc 
        # numpy.random.normal（）函数以正态分布的方式采样，中心设定为0.0。pow()为标准方差，节点数目的-0.5次方
        self.wih = numpy.random.normal(0.0, pow(self.inodes, -0.5), (self.hnodes, self.inodes))
        self.who = numpy.random.normal(0.0, pow(self.hnodes, -0.5), (self.onodes, self.hnodes))

        # learning rate学习率
        self.lr = learningrate
        
        # 激活函数是S型函数  lambda创建的函数没有名称（匿名函数）
        self.activation_function = lambda x: scipy.special.expit(x)
        
        pass

    
    # 训练神经网络
    def train(self, inputs_list, targets_list):
        # 将输入列表转换为2d数组
        inputs = numpy.array(inputs_list, ndmin=2).T
        targets = numpy.array(targets_list, ndmin=2).T  #  将targets_list变成numpy数组
        
        # 将信号计算到隐藏层
        hidden_inputs = numpy.dot(self.wih, inputs)
        # 计算来自隐藏层的信号
        hidden_outputs = self.activation_function(hidden_inputs)
        
        # 将信号计算到最终输出层
        final_inputs = numpy.dot(self.who, hidden_outputs)   #  numpy.dot进行矩阵乘法
        # 计算来自最终输出层的信号
        final_outputs = self.activation_function(final_inputs)
        
        # 输出层错误为（目标-实际）
        output_errors = targets - final_outputs
        # 隐藏层错误是输出错误，按权重拆分，在隐藏节点处重新组合
        hidden_errors = numpy.dot(self.who.T, output_errors) 
        
        # 更新隐藏层和输出层之间链接的权重
        self.who += self.lr * numpy.dot((output_errors * final_outputs * (1.0 - final_outputs)), numpy.transpose(hidden_outputs))
        
        # 更新输入层和隐藏层之间链接的权重
        self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (1.0 - hidden_outputs)), numpy.transpose(inputs))
        
        pass

    
    # 查询神经网络
    def query(self, inputs_list):
        # 将输入列表转换为2d数组
        inputs = numpy.array(inputs_list, ndmin=2).T
        
        # 将信号计算到隐藏层
        hidden_inputs = numpy.dot(self.wih, inputs)
        # 计算来自隐藏层的信号
        hidden_outputs = self.activation_function(hidden_inputs)
        
        # 将信号计算到最终输出层
        final_inputs = numpy.dot(self.who, hidden_outputs)
        # 计算来自最终输出层的信号
        final_outputs = self.activation_function(final_inputs)
        
        return final_outputs
# 输入、隐藏和输出节点的数量
input_nodes = 3
hidden_nodes = 3
output_nodes = 3

# learning rate is 0.3
learning_rate = 0.3

# create instance of neural network创建神经网络实例
n = neuralNetwork(input_nodes,hidden_nodes,output_nodes, learning_rate)
# test query (doesn't mean anything useful yet)测试查询
n.query([1.0, 0.5, -1.5])

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import numpy
import matplotlib.pyplot
# %matplotlib inline
# open the CSV file and read its contents into a list
data_file = open("/content/drive/MyDrive/Colab Notebooks/mnist_train_100.csv", 'r')
data_list = data_file.readlines()
data_file.close()
# check the number of data records (examples)
len(data_list)
# show a dataset record
# the first number is the label, the rest are pixel colour values (greyscale 0-255)
data_list[1]
# take the data from a record, rearrange it into a 28*28 array and plot it as an image
all_values = data_list[1].split(',')
image_array = numpy.asfarray(all_values[1:]).reshape((28,28))
matplotlib.pyplot.imshow(image_array, cmap='Greys', interpolation='None')
# scale input to range 0.01 to 1.00
scaled_input = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01
print(scaled_input)
#output nodes is 10 (example)
onodes = 10
targets = numpy.zeros(onodes) + 0.01
targets[int(all_values[0])] = 0.99
print(targets)

# Commented out IPython magic to ensure Python compatibility.
import numpy
import scipy.special   #  SciPy Python库中函数中，S函数称为expit（）
import matplotlib.pyplot  #  用于打印阵列的库
# 确保绘图位于此笔记本内，而不是外部窗口
# %matplotlib inline
class neuralNetwork:   #神经网络类定义
    
    # 初始化神经网络
    def __init__(self, inputnodes, hiddennodes, outputnodes, learningrate):
        self.inodes = inputnodes   #设置每个输入、隐藏、输出层中的节点数
        self.hnodes = hiddennodes
        self.onodes = outputnodes
        
        #  链接权重矩阵，wih和who
        self.wih = numpy.random.normal(0.0, pow(self.inodes, -0.5), (self.hnodes, self.inodes))
        self.who = numpy.random.normal(0.0, pow(self.hnodes, -0.5), (self.onodes, self.hnodes))
        self.lr = learningrate
        self.activation_function = lambda x: scipy.special.expit(x)   #激活函数是S形函数  
        pass

    
    # 训练神经网络
    def train(self, inputs_list, targets_list):
        inputs = numpy.array(inputs_list, ndmin=2).T   #将输入列表转换为2d数组
        targets = numpy.array(targets_list, ndmin=2).T
        
        hidden_inputs = numpy.dot(self.wih, inputs)   #将信号计算到隐藏层
        hidden_outputs = self.activation_function(hidden_inputs)   #计算来自隐藏层的信号
        
        final_inputs = numpy.dot(self.who, hidden_outputs)   #将信号计算到最终输出层
        final_outputs = self.activation_function(final_inputs)   #计算来自最终输出层的信号
        
        output_errors = targets - final_outputs  #输出层错误为（目标-实际）
        hidden_errors = numpy.dot(self.who.T, output_errors)   #隐藏层错误是输出错误，按权重拆分，在隐藏节点处重新组合
        
        #更新隐藏层和输出层之间链接的权重
        self.who += self.lr * numpy.dot((output_errors * final_outputs * (1.0 - final_outputs)), numpy.transpose(hidden_outputs))  
        
        #更新输入层和隐藏层之间链接的权重
        self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (1.0 - hidden_outputs)), numpy.transpose(inputs))
        
        pass

    
    # 查询神经网络
    def query(self, inputs_list):
        inputs = numpy.array(inputs_list, ndmin=2).T   #将输入列表转换为2d数组
        
        hidden_inputs = numpy.dot(self.wih, inputs)    #将信号计算到隐藏层
        hidden_outputs = self.activation_function(hidden_inputs)  #计算来自隐藏层的信号
        
        final_inputs = numpy.dot(self.who, hidden_outputs)   #将信号计算到最终输出层
        final_outputs = self.activation_function(final_inputs)   #计算来自最终输出层的信号
        
        return final_outputs
# 输入、隐藏和输出节点的数量
input_nodes = 784
hidden_nodes = 200
output_nodes = 10

learning_rate = 0.1

#创建神经网络实例
n = neuralNetwork(input_nodes,hidden_nodes,output_nodes, learning_rate)
# 将mnist训练数据CSV文件加载到列表中
training_data_file = open("/content/drive/MyDrive/Colab Notebooks/mnist_train.csv", 'r')
training_data_list = training_data_file.readlines()
training_data_file.close()
# 训练神经网络

# epocs是训练数据集用于训练的次数
epochs = 5

for e in range(epochs):
    # 检查培训数据集中的所有记录
    for record in training_data_list:
        all_values = record.split(',')  #用“，”逗号分隔记录
        inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01   #缩放和移动输入  输入范围0-1
        targets = numpy.zeros(output_nodes) + 0.01   #创建目标输出值（除0.99的所需标签外，所有值均为0.01）
        targets[int(all_values[0])] = 0.99   #all_values[0]是此记录的目标标签
        n.train(inputs, targets)
        pass
    pass
# 将mnist测试数据CSV文件加载到列表中
test_data_file = open("/content/drive/MyDrive/Colab Notebooks/mnist_test.csv", 'r')
test_data_list = test_data_file.readlines()
test_data_file.close()
# 测试神经网络

# 网络绩效记分卡，最初为空
scorecard = []

# 检查测试数据集中的所有记录
for record in test_data_list:
    all_values = record.split(',')   #用“，”逗号分隔记录
    correct_label = int(all_values[0])   #正确答案是第一个值
    inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01   #缩放和移动输入
    # 查询网络
    outputs = n.query(inputs)
    label = numpy.argmax(outputs)   #最高值的索引对应于标签
    if (label == correct_label):   #将正确或不正确附加到列表
        scorecard.append(1)     #网络的答案与正确答案匹配，在记分卡中添加1
    else:
        scorecard.append(0)     #网络的答案与正确答案不匹配，请将0添加到记分卡
        pass
    
    pass
# 计算成绩分数，正确答案的分数
scorecard_array = numpy.asarray(scorecard)
print ("performance = ", scorecard_array.sum() / scorecard_array.size)